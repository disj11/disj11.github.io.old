{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/data-structure/union-find/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Dev Logs","author":"tykim","siteUrl":"https://disj11.github.io/old","comment":{"disqusShortName":"","utterances":"disj11/disj11.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"4ad200a2-884f-5c46-9be5-2ca02f2936cf","excerpt":"개요 유니온 파인드는 Disjoint Set (서로소 집합) 또는 Merge Find Set (병렬 찾기 집합) 으로 불리며, 말 그대로 서로소인 집합들을 표현하는 자료구조이다. 즉, 어떤 집합 사이에도 교집합의 원소가\n하나도 없고, 모든 집합의 합집합은 전체 집합과 같다는 말이다. 기본적으로 union, find 단 2개의 연산만을 지원한다. 예시 {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8} 위 집합들은 아무런 연산이 가해지지 않은 제일 초기의 크기…","html":"<h2 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h2>\n<p>유니온 파인드는 Disjoint Set (서로소 집합) 또는 Merge Find Set (병렬 찾기 집합) 으로 불리며, 말 그대로 서로소인 집합들을 표현하는 자료구조이다. 즉, 어떤 집합 사이에도 교집합의 원소가\n하나도 없고, 모든 집합의 합집합은 전체 집합과 같다는 말이다. 기본적으로 union, find 단 2개의 연산만을 지원한다.</p>\n<h2 id=\"예시\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시</h2>\n<p>{1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}<br>\n위 집합들은 아무런 연산이 가해지지 않은 제일 초기의 크기 8인 유니온 파인드이고, 포함하고 있는 집합 또한 8개 이다.</p>\n<p>몇 번의 연산이 이루어 진 후 {1, 2, 5, 6, 8}, {3, 4}, {7} 의 형태가 되었다.<br>\n아래의 그림은 변경 후 상태를 나타내는 포레스트이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABt0lEQVQoz42RSS9DURTHz1JE7CQ+ALHwAXwBKwt2dhLa1IYEKzXEvCNIhBAxxMKQiDxTw6vSkiDSRtEaagr6vJjqNaYO794j9930hSpxFi8v//x/53/OPYCIKqGIOOI4B9N8i+BFREKprs+5/Knllvppj674JCXDbM3r2oSISl7DKiLmd22BYSWnwU6iEUSklHJrcd8OlFizzWuRUEhlAvaLPjCKSWU2YD6m4JpHLhlybRzd6cn8e+RXigadgtOvJz8GPwzDrmbBC6sHt00zngs5iIhjjrMB2yklhHekGiw/vdZNun3+Z4wpekFa5TIUi52Lx+6LBzAtQam44LzhIVoMFvbugMGa07rOWI1hG1FmgPye7ZQqm2VXelDeshodmY0bnusAn1nVzO2Wk+RKW8X4nibit+SX9/D1fZAvfik9O09k1CO0Ugm9lJVQOIo/Cghli1BEElUNo+70GrsQG5s7Yo+HCWDtJOyFAspbZq0djGL1BJsw+sVOEqKI8LX9klsyT+1/hCNxk/9WoP9x96mktM4e7l8F9I7/gvmSBd1bYBRzOzZRu9TfeDzcJnjBtFyV6DA/4U/q0LXYRsEIFAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"union find forest\"\n        title=\"union find forest\"\n        src=\"/static/bb883c1ffa46b4df5428647c946d7f09/dd45a/union-find-forest.png\"\n        srcset=\"/static/bb883c1ffa46b4df5428647c946d7f09/5a46d/union-find-forest.png 300w,\n/static/bb883c1ffa46b4df5428647c946d7f09/dd45a/union-find-forest.png 550w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>가장 위에 있는 노드가 각 트리의 루트라고 한다면, 그 트리에 속한 정점들은 모두 같은 집합에 속해있다. 같은 집합이더라도 표현할 수 있는 방법은 수 없이 많으며, 위 그림은 그 중 한가지를 표현해 놓은 것이다.</p>\n<h2 id=\"구현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-label=\"구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현</h2>\n<h3 id=\"find-연산\" style=\"position:relative;\"><a href=\"#find-%EC%97%B0%EC%82%B0\" aria-label=\"find 연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>find 연산</h3>\n<p>두 원소가 같은 집합에 속해 있는지 확인하려면, 두 원소의 루트를 찾아 루트가 서로 같은지 비교하면 된다. 그러기 위해서 필요한 연산이 <strong>find</strong> 연산으로, 어떤 정점의 루트를 찾아주는\n역할을 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * 원소 n을 받아 n의 root노드를 반환\n * @param n 루트를 찾을 정점\n * @return root 노드\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n   <span class=\"token keyword\">return</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>자신의 부모를 가리키는 배열이 parent 이고, 루트의 값은 -1 이라고 가정하여 짜본 코드인데, 이 코드의 한 가지 문제점이 있다. 위의 그림과 같은 트리에서 find(6)을 수행한다면, 6부터 2까지의 경로가 일직선이기 때문에, 많은\n재귀 호출이 이루어진다는 것이다. 한번 개선 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n   \n   parent<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>별로 바뀐 것이\n없어보이지만 파인드 연산을 수행할 때마다 트리의 구조를 평평하게 만들어 경로를 압축하였다. 최종적으로는 아래와 같은 그림이 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 609px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABXUlEQVQY0z2PTUgCYRCGP7pFVBAdC6Jjx27RNToF3julSRCaZYTSoQJJuvRzKAK1Q5cgo7SgZF1XTZb8QwpNDSP7c03KSFCkdvfbb2rXcE4z7zDvMy8CAIkAACy70mjqfC+YBwBMFEleyU2m8NVr9qm2oz+8AACu+Gu7gTI5kwhLBBMALA5bWKRhxjauBBGLih+WCC9KAGD33iM13amns4UKAGhscaQN9Bsp9E+QCJMqGQ6S0VxZEDAWMVbuiUKu1nnz0a1Nfkoes1xl3J44TXDoMPKy4s6UK3XPzZvVnRF5YT/0ZHKmih9VWyC/7skRSfrmRYs7fXHNNYM0CnXM0GiSXj1ODiyFkJbROWJ9i5dIH5zYDXcb/UhDhbIlB/OA1HTPgr/4WWvEwUR2QUNrbOsszWaKqp1Yi857Fnse2Yy0zflOwo+DVrZr3seVa+zdO5qmRrcigiA2s/yRfwE8whUR/x6wQAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"union find forest2\"\n        title=\"union find forest2\"\n        src=\"/static/06e2b549e7105cf540ca134f4d6df89d/d0d8c/union-find-forest2.png\"\n        srcset=\"/static/06e2b549e7105cf540ca134f4d6df89d/5a46d/union-find-forest2.png 300w,\n/static/06e2b549e7105cf540ca134f4d6df89d/0a47e/union-find-forest2.png 600w,\n/static/06e2b549e7105cf540ca134f4d6df89d/d0d8c/union-find-forest2.png 609w\"\n        sizes=\"(max-width: 609px) 100vw, 609px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이렇게 바뀐 로직의 시간 복잡도는 선형 시간과 거의 동급으로 취급한다.\n(크기가 N인 유니온 파인드 구조에 M번 find 연산을 한다면, 최악의 시간 복잡도는 O(MN).)</p>\n<p>정확히는 O(Mlog * N) 이지만 저 로그 스타라는 함수는 아크만 함수의 역함수로 매우 느리게 증가해서 O(M)으로 봐도 무방하다.</p>\n<h3 id=\"union-연산\" style=\"position:relative;\"><a href=\"#union-%EC%97%B0%EC%82%B0\" aria-label=\"union 연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>union 연산</h3>\n<p>두 집합을 하나로 합쳐주는 연산이다. Union-Find 자료구조의 연산은 알아본 바와 같이 find 연산, union 연산 두 가지 뿐이라서, 한 번 합친 집합을 다시 분할하는 것은 굉장히 힘들지만, 보통 합치는 작업만 필요할 때 유용하다. 그럼 union 연산을 구현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token operator\">=</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    b<span class=\"token operator\">=</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">!=</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        parent<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>a\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>굉장히 구현이 간단하다. b의 루트의 부모를 a로 만들면 된다. 함수명이 union 이 아니라 merge 인 이유는 C언어 공용체(union) 전용 키워드가 union 이기 때문에 사용하지 못하기 때문. union 연산의 시간 복잡도도 find 연산과 마찬가지로 O(M)으로 봐도 무방하다.</p>\n<hr>\n<p>[참고 사이트]<br>\n<a href=\"https://kks227.blog.me/\">https://kks227.blog.me/</a></p>","frontmatter":{"title":"Union-Find (유니온 파인드)","date":"June 05, 2019"}}},"pageContext":{"slug":"/data-structure/union-find/","previous":{"fields":{"slug":"/data-structure/inverted-index/"},"frontmatter":{"title":"Inverted index (역색인)"}},"next":{"fields":{"slug":"/database/role-based-access-control-table-structure/"},"frontmatter":{"title":"역할 기반 접근 제어를 위한 테이블 설계"}}}},
    "staticQueryHashes": ["3078735561","3128451518"]}