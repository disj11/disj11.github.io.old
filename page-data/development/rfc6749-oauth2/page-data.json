{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/development/rfc6749-oauth2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Dev Logs","author":"tykim","siteUrl":"https://disj11.github.io","comment":{"disqusShortName":"","utterances":"disj11/disj11.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"bbc04517-e0ea-5f2b-96eb-0caf1657f977","excerpt":"Introduction OAuth는 오픈 API의 인증(authentication; 이 사용자가 누구인가?)과 권한 부여(authorization; 로그인 한 사용자가 무엇을 할 수 있는가?)를 제공하기 위해 만들어진 프로토콜이다. OAuth 1.0을 거쳐 현재는 OAuth 2.0 표준안인 RFC 6749가 널리 사용되고 있다. OAuth 2.0에 대해 알아보자. Rules OAuth 2.0에서는 아래와 같이 4가지 역할을 정의한다. 리소스 소유자 (Resource Owner…","html":"<h1 id=\"introduction\" style=\"position:relative;\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h1>\n<p>OAuth는 오픈 API의 인증(authentication; 이 사용자가 누구인가?)과 권한 부여(authorization; 로그인 한 사용자가 무엇을 할 수 있는가?)를 제공하기 위해 만들어진 프로토콜이다. OAuth 1.0을 거쳐 현재는 OAuth 2.0 표준안인 <a href=\"https://datatracker.ietf.org/doc/html/rfc6749\">RFC 6749</a>가 널리 사용되고 있다. OAuth 2.0에 대해 알아보자.</p>\n<h2 id=\"rules\" style=\"position:relative;\"><a href=\"#rules\" aria-label=\"rules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rules</h2>\n<p>OAuth 2.0에서는 아래와 같이 4가지 역할을 정의한다.</p>\n<ol>\n<li>리소스 소유자 (Resource Owner)<br>\n보호된 리소스의 소유자를 뜻한다. 예를 들어 계좌 잔액이라는 리소스가 있다고 한다면, 계좌의 소유자가 리소스 소유자에 해당된다.</li>\n<li>리소스 서버 (Resource Service)<br>\n보호된 리소스를 제공하는 서버를 의미한다. 예를 들어 오픈뱅킹 서버를 들 수 있다. 오픈뱅킹 서버는 은행들의 API를 사용하여 계좌와 관련된 각종 리소스를 제공해주는 리소스 서버이다.</li>\n<li>클라이언트 (Client)<br>\n오픈 API를 호출하는 응용 프로그램을 의미한다.</li>\n<li>인증 서버 (Authorization Server)<br>\n리소스 소유자로부터 접근 권한을 획득한 이후에 자원에 접근하기 위한 토큰(Access Token)을 발급해주는 서버를 말한다.</li>\n</ol>\n<h2 id=\"protocol-flow\" style=\"position:relative;\"><a href=\"#protocol-flow\" aria-label=\"protocol flow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Protocol Flow</h2>\n<p>다음의 표는 OAuth 2.0의 대략적인 흐름을 나타낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+--------+                               +---------------+\n|        |--(1)- Authorization Request ->|   Resource    |\n|        |                               |     Owner     |\n|        |&lt;-(2)-- Authorization Grant ---|               |\n|        |                               +---------------+\n|        |\n|        |                               +---------------+\n|        |--(3)-- Authorization Grant -->| Authorization |\n| Client |                               |     Server    |\n|        |&lt;-(4)----- Access Token -------|               |\n|        |                               +---------------+\n|        |\n|        |                               +---------------+\n|        |--(5)----- Access Token ------>|    Resource   |\n|        |                               |     Server    |\n|        |&lt;-(6)--- Protected Resource ---|               |\n+--------+                               +---------------+</code></pre></div>\n<ol>\n<li>클라이언트는 리소스 서버에 접속하여 API를 사용하기 위해, 먼저 리소스 소유자에게 인증을 요청해야한다. 인증 요청은 리소스 소유자에게 직접 할 수도 있지만, 중간에 인증 서버를 통해 간접적으로 하는 것이 좋다.</li>\n<li>클라이언트는 인가 승인을 받는다. 인가 승인은 <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-1.3\">인가 승인 유형</a> 중 한 가지를 선택하여 사용한다.</li>\n<li>클라이언트는 리소스 서버에게 (2)에서 승인 받은 인가를 제시하여 Access Token을 요청한다.</li>\n<li>리소스 서버는 클라이언트의 권한이 유효한지 확인하고, 유효한 경우 Acess Token을 발급한다.</li>\n<li>클라이언트는 Access Token을 사용하여 리소스 서버에게 보호된 리소스를 요청한다.</li>\n<li>리소스 서버는 Access Token이 유효한지 확인하고, 유효한 경우 리소스를 제공한다.</li>\n</ol>\n<h2 id=\"access-token\" style=\"position:relative;\"><a href=\"#access-token\" aria-label=\"access token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token</h2>\n<p>Access Token은 보호된 리소스에 접근하기 위해 사용된다. 클라이언트에게 발급된 인가를 나타내는 문자열이며, 보통 클라이언트가 알아볼 수 없다. 토큰에는 리소스에 접근할 수 있는 범위와 기간이 명시된다. 리소스 소유자에 의해 생성되고, 리소스 서버와 인증 서버에서 사용된다.</p>\n<h2 id=\"refresh-token\" style=\"position:relative;\"><a href=\"#refresh-token\" aria-label=\"refresh token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Refresh Token</h2>\n<p>Refresh Token은 접근 토큰을 얻는 데 사용된다. Access Token이 유효하지 않거나 만료된 경우 새로운 Access Token을 얻거나, 동일하거나 더 좁은 범위로 추가적인 Access Token을 얻기 위해 사용된다. Refresh Token의 발급은 인증 서버의 선택 사항이다. 만약 인가 서버가 Refresh Token을 발급한다면 <a href=\"#protocol-flow\">Protocol Flow</a>의 2번에서 Access Token과 함께 발급한다.</p>\n<p>Refresh Token은 클라이언트가 리소스 소유자에 의해 인가가 승인되었음을 나타내는 문자열이며, 보통 클라이언트가 알아볼 수 없다. AccessToken과는 달리 인증 서버에서만 사용되며, 리소스 서버로 전송되지 않는다. 아래의 표는 Refresh Token을 이용해 Access Token을 갱신하는 흐름이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+--------+                                           +---------------+\n|        |--(1)------- Authorization Grant --------->|               |\n|        |                                           |               |\n|        |&lt;-(2)----------- Access Token -------------|               |\n|        |               &amp; Refresh Token             |               |\n|        |                                           |               |\n|        |                            +----------+   |               |\n|        |--(3)---- Access Token ---->|          |   |               |\n|        |                            |          |   |               |\n|        |&lt;-(4)- Protected Resource --| Resource |   | Authorization |\n| Client |                            |  Server  |   |     Server    |\n|        |--(5)---- Access Token ---->|          |   |               |\n|        |                            |          |   |               |\n|        |&lt;-(6)- Invalid Token Error -|          |   |               |\n|        |                            +----------+   |               |\n|        |                                           |               |\n|        |--(7)----------- Refresh Token ----------->|               |\n|        |                                           |               |\n|        |&lt;-(8)----------- Access Token -------------|               |</code></pre></div>\n<h1 id=\"obtaining-authorization\" style=\"position:relative;\"><a href=\"#obtaining-authorization\" aria-label=\"obtaining authorization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Obtaining Authorization</h1>\n<p>OAuth는 네 가지 승인 유형(Authorization Code Grant, Implicit Grant, Authorization Request, Access Token Response)을 제공한다. 이 포스팅에서는 네이버, 카카오 등에서 가장 많이 사용되는 Authorization Code Grant 방식에 대해서만 설명한다. 다른 승인 유형에 관한 내용은 <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-4.1\">rfc6749#section-4.1</a>를 참고한다.</p>\n<h2 id=\"authorization-code-grant\" style=\"position:relative;\"><a href=\"#authorization-code-grant\" aria-label=\"authorization code grant permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Authorization Code Grant</h2>\n<p>이 승인 유형은 Access Token과 Refresh Token을 모두 발급받기 위해 사용된다. 기밀 클라이언트에 최적화 되어 있다. 리다이렉션을 기반으로 동작하기 때문에 클라이언트는 리소스 소유자의 User-Agent(일반적으로 웹 브라우저)와 상호작용 할 수 있어야 하며, 인증 서버로부터 들어오는 요청을 받을 수 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+----------+\n| Resource |\n|   Owner  |\n|          |\n+----------+\n     ^\n     |\n    (2)\n+----|-----+          Client Identifier      +---------------+\n|         -+----(1)-- &amp; Redirection URI ---->|               |\n|  User-   |                                 | Authorization |\n|  Agent  -+----(2)-- User authenticates --->|     Server    |\n|          |                                 |               |\n|         -+----(3)-- Authorization Code ---&lt;|               |\n+-|----|---+                                 +---------------+\n  |    |                                         ^      v\n (1)  (3)                                        |      |\n  |    |                                         |      |\n  ^    v                                         |      |\n+---------+                                      |      |\n|         |>---(4)-- Authorization Code ---------'      |\n|  Client |          &amp; Redirection URI                  |\n|         |                                             |\n|         |&lt;---(5)----- Access Token -------------------'\n+---------+       (w/ Optional Refresh Token)</code></pre></div>\n<blockquote>\n<p><strong>NOTE</strong>: 1,2,3 단계는 User-Agent를 통해 전달되므로 부 부분으로 나뉘어 짐</p>\n</blockquote>\n<ol>\n<li>클라이언트가 리소스 소유자의 User-Agent를 인증 Endpoint로 이동시키며 흐름이 시작된다. 클라이언트는 자신의 식별자, requested scope, local state, 인증이 승인 또는 거부될 경우 User-Agent를 돌려보낼 리다이렉션 URI을 포함한다.</li>\n<li>인증 서버는 User-Agent를 통해 리소스 소유자를 인증하고, 리소스 소유자는 User-Agent를 통해 클라이언트의 접근 요청에 승인 혹은 거부할 지 결정한다.</li>\n<li>리소스 소유자가 접근 요청을 승인했다고 가정하여, 인증 서버는 User-Agent를 제공된 리다이렉션 URI로 이동시킨다. 이때 리다이렉션 URI에는 인증 코드와 local state가 포함된다.</li>\n<li>클라이언트는 이전 단계에서 받은 인증 코드를 포함하여 인증 서버에 Access Token을 요청한다. 이 때 인증 코드를 얻기 위해 사용했던(3번 과정) 리다이렉션 URI을 포함한다. 요청을 보낼때 클라이언트는 인증 서버에 인증한다.</li>\n<li>인증 서버는 인증 코드가 유효한지 확인하고, 3번에서 사용한 리다이렉션 URI와 4번에서 전달받은 리다이렉션 URI가 동일한지 확인한다. 유효하다는 게 확인되면 Access Token과, (선택적으로) Refresh Token을 응답한다.</li>\n</ol>\n<p>1번, 2번 과정의 이해를 돕기 위해 다음 그림을 보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC7ElEQVQ4y21U204TURTln3z1wQfDB5CYFAHBhLEXEhM+wgQTiBd8NbxKNPHFRBPkIlEsrdyEaaGlV0qHTi/TmbZz5r7MPtMpUNnJyjlzZmbttdeePSM6Y2CGMYBhmjAti683z7ptBfVCDvXiXcijnj9HR2lhhAhd14XneRy2bYMxBsdx+DXdo0gn4og+nUFEmEVMmEWU1mcCx1wkjPDUBPa3N28TUmiaikwmA8uy+LXrOnw93vmJWCSC5/PzCEdjiMzNQQhHIITDEKIxTE9OILG5fk1Ioes9yHINzWYDtVoNlmUC8BMVj4+wuLCAD6urkCQJ2WwWiqJA0zRuyenfIyS3NjDCDAbHBUdbNVCVmpDrKqSrFrSOw88pcod7+PzpIw4OD9Hr9bgtN0MqFX1C0wZql18gpe/hUnyI3MEocoejKB6Pop59gGrqPtptEanEHgrZM96wcrnMPSa/TdPkhKVsBn+I0LAAVTmBUl1Cq/oOcnkZ8sUy6pVltK/eolV9A2bKSCeSOD055i8bhgFd1zlIre26KBLhjw3yUEffwjvD668n8V84S4l8H5RMCgP/K/mcXzI1xbRMaJoCSaqgVqui0ahBliWOXlflpGJ8B5mUCNtx0Gw2/WYYxiDxxS1C+oiZjk6ng263y0EqCAZjA8Iz8YTvO5o2UOj1FZaCkvk0MDYog0DeUHb6Fmm9Seh6Hk8ceBioLJ1n/ab4hKSmy28SSHGwZ0MKLdvmhKSOEprDhLrhwNQL0NoSGk0FhuGPHT3MXzBNn3B3B9l0qj8A+qAauz9RlUL+WqGud/nIUWYym0wP/KRzt69w7dtXFEoliKKIRCKBZDLJ9/liEdvr35HcWu8TMsaJCKqqQpZlvhI01SdM7f7G7Mw0ZgUBgiAgEo1y0J7meWbi8XWXg9KGG0MKA4/o5zAeCiE0OYXQ5OQtjD+ZxqOxMcTX13xCI/gPDsOyfJ88DxdpESuLL7HyavF/vF7C+5cvkDvaxz9LJr/QA9HyJwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"kakao login\"\n        title=\"kakao login\"\n        src=\"/static/c274167fa4425fdbdd03f3c6f457bac5/c1b63/kakao_login.png\"\n        srcset=\"/static/c274167fa4425fdbdd03f3c6f457bac5/5a46d/kakao_login.png 300w,\n/static/c274167fa4425fdbdd03f3c6f457bac5/0a47e/kakao_login.png 600w,\n/static/c274167fa4425fdbdd03f3c6f457bac5/c1b63/kakao_login.png 1200w,\n/static/c274167fa4425fdbdd03f3c6f457bac5/8b640/kakao_login.png 1454w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 이미지에서 파란색 박스(카카오톡으로 로그인)을 클릭하면 1번 과정이 진행되는 것이고, 빨간색 박스의 동의하고 계속하기 버튼을 누르면 2번 과정의 승인을 하는 것이다.</p>\n<h3 id=\"authorization-request\" style=\"position:relative;\"><a href=\"#authorization-request\" aria-label=\"authorization request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Authorization Request</h3>\n<p>클라이언트는 인증 코드 요청을 할 때 <code class=\"language-text\">application/x-www-form-urlencoded</code> 를 사용하여 다음 파라미터를 포함해야한다.</p>\n<ul>\n<li><code class=\"language-text\">response_type</code><br>\n<strong>필수.</strong> “code”로 고정</li>\n<li><code class=\"language-text\">client_id</code><br>\n<strong>필수.</strong> 클라이언트의 식별자</li>\n<li><code class=\"language-text\">redirect_uri</code><br>\n<strong>선택사항.</strong> <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2\">rfc6749#section-3.1.2</a> 참고</li>\n<li><code class=\"language-text\">scope</code><br>\n<strong>선택사항.</strong> <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-3.3\">rfc6749#section-3.3</a> 참고</li>\n<li><code class=\"language-text\">state</code><br>\n<strong>권장사항.</strong> 인증 서버는 User-Agent를 클라이언트로 리다이렉트할 때 이 값을 포함한다. <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-10.12\">section-10.12</a>에 기술된대로 사이트 간 요청 위조(Cross-Site Request Forgery)를 방지하는 데 사용하는 것이 좋다.</li>\n</ul>\n<p>카카오 인가 코드 받기의 경우도 이 규칙을 지켜 다음과 같은 요청을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /oauth/authorize?client_id={REST_API_KEY}&amp;redirect_uri={REDIRECT_URI}&amp;response_type=code HTTP/1.1\nHost: kauth.kakao.com</code></pre></div>\n<h3 id=\"authorization-response\" style=\"position:relative;\"><a href=\"#authorization-response\" aria-label=\"authorization response permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Authorization Response</h3>\n<p>리소스 소유자가 접근 요청을 승인하면, 인증 서버는 다음의 파라미터를 <code class=\"language-text\">application/x-www-form-urlencoded</code> 를 사용하여 클라이언트에게 전달한다.</p>\n<ul>\n<li><code class=\"language-text\">code</code><br>\n<strong>필수.</strong> 인증 서버에서 생성된 인증 코드이다. 유출 위험을 줄이기 위해 만료 시간이 짧아야 하며 최대 10분이 권장된다. 클라이언트는 인증 코드를 두 번 이상 사용하면 안된다. 만약 두번 이상 사용될 경우 인증 서버는 요청을 거부해야 하며, 해당 인증 코드 이전에 발급된 모든 토큰을 취소하는 것이 좋다.</li>\n<li><code class=\"language-text\">state</code><br>\n클라이언트가 인증 요청 시 <code class=\"language-text\">state</code> 파라미터를 포함했다면 <strong>필수.</strong> 클라이언트로부터 전달 받은 값과 동일해야한다.</li>\n</ul>\n<p>카카오 인가 코드 받기의 경우도 이 규칙을 지켜 다음과 같은 응답을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 302 Found\nContent-Length: 0\nLocation: {REDIRECT_URI}?code={AUTHORIZE_CODE}</code></pre></div>\n<h4 id=\"error-response\" style=\"position:relative;\"><a href=\"#error-response\" aria-label=\"error response permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Error Response</h4>\n<p>요청이 누락되거나, 유효하지 않는 경우, 리다이렉션 URI가 일치하지 않는 경우, 클라이언트 식별자가 누락되거나 유효하지 않는 경우는 User-Agent를 유효하지 않은 URI로 리다이렉트 되게 해서는 안된다. 이 경우에 인증 서버는 다음 파라미터를 사용하여 리소스 소유자에게 오류를 알려주는 것이 좋다. 이 역시 <code class=\"language-text\">application/x-www-form-urlencoded</code> 방식을 사용한다.</p>\n<ul>\n<li><code class=\"language-text\">error</code><br>\n<strong>필수.</strong> 다음의 에러 코드 사용\n<ul>\n<li>invalid_request<br>\n요청 시 필수 파라미터의 누락, 유효하지 않은 파라미터 포함, 파라미터를 두 번 이상 포함 등</li>\n<li>unauthorized_client<br>\n클라이언트가 이 인가 승인 유형을 사용할 권한이 없음</li>\n<li>access_denied<br>\n리소스 소유자 또는 인증 서버가 요청을 거부</li>\n<li>unsupported_response_type<br>\n인증 서버가 Authorization Code Grant 유형을 지원하지 않음</li>\n<li>invalid_scope<br>\n요청한 scope가 유효하지 않거나, 알 수 없거나, 손상된 경우</li>\n<li>server_error<br>\n인증 서버에 예기치 못한 오류가 발생 (500 Internal Server Error 상태 코드는 HTTP redirect를 통해 클라이언트에게 전달 될 수 없기 때문에 이 오류 코드가 필요)</li>\n<li>temporarily_unavailable<br>\n인증 서버의 과부하 또는 유지보수로 인해 요청을 처리할 수 없음 (503 Service Unavailable 상태 코드는 HTTP redirect를 통해 클라이언트에게 전달 될 수 없기 때문에 이 오류 코드가 필요)</li>\n</ul>\n</li>\n<li><code class=\"language-text\">error_description</code><br>\n<strong>선택사항.</strong> 클라이언트 개발자가 발생한 오류를 이해하는 데 도움을 주는 정보를 제공한다. 사람이 읽을 수 있는 문자로 %x20-21 / %x23-5B / %x5D-7E 범위를 벗어나는 문자를 사용하면 안된다.</li>\n<li><code class=\"language-text\">error_uri</code><br>\n<strong>선택사항.</strong> 클라이언트 개발자를 위해 발생한 오류와 관련된 추가 정보를 제공한다. %x21 / %x23-5B / %x5D-7E 범위를 벗어나는 문자를 사용하면 안된다.</li>\n<li><code class=\"language-text\">state</code><br>\n클라이언트가 인증 요청 시 <code class=\"language-text\">state</code> 파라미터를 포함했다면 <strong>필수.</strong> 클라이언트로부터 전달 받은 값과 동일해야한다.</li>\n</ul>\n<p>카카오의 경우도 리소스 접근 요청 단계에서 로그인을 취소할 시 다음과 같은 응답이 온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 302 Found\nContent-Length: 0\nLocation: {REDIRECT_URI}?error=access_denied&amp;error_description=User%20denied%20access</code></pre></div>\n<h3 id=\"access-token-request\" style=\"position:relative;\"><a href=\"#access-token-request\" aria-label=\"access token request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token Request</h3>\n<p>클라이언트는 토큰 요청시 UTF-8 인코딩을 사용하여 <code class=\"language-text\">application/x-www-form-urlencoded</code> 형식으로 된 다음과 같은 파라미터를 body에 담아야한다.</p>\n<ul>\n<li><code class=\"language-text\">grant_type</code><br>\n<strong>필수.</strong> 값은 “authorization_code”로 고정</li>\n<li><code class=\"language-text\">code</code><br>\n<strong>필수.</strong> 인증 서버로부터 받은 인증 코드</li>\n<li><code class=\"language-text\">redirect_uri</code><br>\n인증 요청 시 <code class=\"language-text\">redirect_uri</code>가 존재했다면 <strong>필수</strong>이며, 인증 요청 시 사용했던 값과 동일해야 한다.</li>\n<li><code class=\"language-text\">client_id</code><br>\n클라이언트가 인증 서버와 인증하지 않는 경우 <strong>필수.</strong></li>\n</ul>\n<blockquote>\n<p>클라이언트 인증에 관해서는 이 포스팅에서 설명하지 않으며, 혹시 내용이 궁금하다면 <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1\">rfc6749#section-3.2.1</a>를 참고한다.</p>\n</blockquote>\n<h3 id=\"access-token-response\" style=\"position:relative;\"><a href=\"#access-token-response\" aria-label=\"access token response permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Access Token Response</h3>\n<p>Access Token 요청이 유효하고 인증되었다면, 인증 서버는 Access Token과 선택적으로 갱신 토큰을 발급한다.</p>\n<h4 id=\"successful-response\" style=\"position:relative;\"><a href=\"#successful-response\" aria-label=\"successful response permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Successful Response</h4>\n<p>인증 서버는 Access Token과 선택적으로 갱신 토큰을 발급하고, 다음 파라미터를 200 (OK) 상태 코드로 응답한다. 파라미터는 <code class=\"language-text\">application/json</code> 유형을 사용하여 HTTP Response Body에 포함한다.</p>\n<ul>\n<li><code class=\"language-text\">access_token</code><br>\n<strong>필수.</strong> 인증 서버가 발급한 Access Token</li>\n<li><code class=\"language-text\">token_type</code><br>\n<strong>필수.</strong> <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-7.1\">rfc6749#section-7.1</a>에 기술된 토큰의 타입으로 보통 <code class=\"language-text\">baerer</code> 타입을 많이 사용한다.</li>\n<li><code class=\"language-text\">expires_in</code><br>\n<strong>권장사항.</strong> 초 단위의 Access Token 수명. 예를 들어 값이 3600이라면 토큰이 생성된 시간으로부터 3600초(1 시간) 뒤에 만료된다는 의미이다.</li>\n<li><code class=\"language-text\">refresh_token</code><br>\n<strong>선택사항.</strong> Refresh Token으로 <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-6\">rfc6749#section-6</a>에 기술된 대로 새로운 Access Token을 발급 받는데 사용한다.</li>\n<li><code class=\"language-text\">scope</code><br>\n클라이언트가 요청한 범위와 동일하다면 <strong>선택사항.</strong> 그렇지 않은 경우 <strong>필수.</strong> <a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-3.3\">rfc6749#section-3.3</a>에 기술된 Access Token의 범위이다.</li>\n</ul>\n<p>카카오의 경우 다음과 같은 응답이 온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\n{\n    \"token_type\":\"bearer\",\n    \"access_token\":\"{ACCESS_TOKEN}\",\n    \"expires_in\":43199,\n    \"refresh_token\":\"{REFRESH_TOKEN}\",\n    \"refresh_token_expires_in\":25184000,\n    \"scope\":\"account_email profile\"\n}</code></pre></div>\n<h4 id=\"error-response-1\" style=\"position:relative;\"><a href=\"#error-response-1\" aria-label=\"error response 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Error Response</h4>\n<p>인증 서버는 다음 파라미터를 400 (Bad Request) 상태 코드로 응답한다. 파라미터는 <code class=\"language-text\">application/json</code> 유형을 사용하여 HTTP Response Body에 포함한다.</p>\n<ul>\n<li><code class=\"language-text\">error</code><br>\n<strong>필수.</strong> 다음의 에러 코드 사용\n<ul>\n<li>invalid_request<br>\n요청 시 필수 파라미터의 누락, 유효하지 않은 파라미터 포함, 파라미터를 두 번 이상 포함 등</li>\n<li>invalid_client<br>\n클라이언트가 인증에 실패한 경우 (e.g. 알 수 없는 클라이언트, 클라이언트 인증이 포함되지 않음, 지원되지 않는 인증 방법).</li>\n<li>invalid_grant<br>\n인가 승인 유형 또는 Refresh Token이 유효하지 않거나, 만료, 취소된 경우 또는 인증 요청에 사용된 리다이렉션 URI가 일치하지 않거나 다른 클라이언트에게 발급된 경우</li>\n<li>unauthorized_client<br>\n클라이언트가 이 인가 승인 유형을 사용할 권한이 없음</li>\n<li>access_denied<br>\n리소스 소유자 또는 인증 서버가 요청을 거부</li>\n<li>unsupported_grant_type<br>\n서버가 지원하지 않는 인가 승인 유형인 경우</li>\n<li>temporarily_unavailable<br>\n인증 서버의 과부하 또는 유지보수로 인해 요청을 처리할 수 없음 (503 Service Unavailable 상태 코드는 HTTP redirect를 통해 클라이언트에게 전달 될 수 없기 때문에 이 오류 코드가 필요)</li>\n<li>invalid_scope<br>\n요청한 scope가 유효하지 않거나, 알 수 없거나, 손상된 경우</li>\n</ul>\n</li>\n<li><code class=\"language-text\">error_description</code><br>\n<strong>선택사항.</strong> 클라이언트 개발자가 발생한 오류를 이해하는 데 도움을 주는 정보를 제공한다. 사람이 읽을 수 있는 문자로 %x20-21 / %x23-5B / %x5D-7E 범위를 벗어나는 문자를 사용하면 안된다.</li>\n<li><code class=\"language-text\">error_uri</code><br>\n<strong>선택사항.</strong> 클라이언트 개발자를 위해 발생한 오류와 관련된 추가 정보를 제공한다. %x21 / %x23-5B / %x5D-7E 범위를 벗어나는 문자를 사용하면 안된다.</li>\n</ul>\n<p>예를 들어 다음과 같은 실패 응답이 존재할 수 있음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 400 Bad Request\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n    \"error\":\"invalid_request\"\n}</code></pre></div>\n<h1 id=\"사용-예\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9-%EC%98%88\" aria-label=\"사용 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용 예</h1>\n<h2 id=\"카카오\" style=\"position:relative;\"><a href=\"#%EC%B9%B4%EC%B9%B4%EC%98%A4\" aria-label=\"카카오 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>카카오</h2>\n<p>우리가 잘 아는 카카오에서도 OAuth를 사용한다. <a href=\"https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api\">카카오 로그인</a> REST API 문서를 확인해보면, 카카오 로그인을 위해서 인가 코드 받기, 토큰 받기 두 과정을 거친다. 이 과정이 <a href=\"#authorization-code-grant\">Authorization Code Grant</a>와 동일하다. 이렇게 발급받은 토큰은 <a href=\"https://developers.kakao.com/docs/latest/ko/kakaostory/rest-api\">카카오스토리 API</a> 등을 사용할 때 필요하다. 예를 들어 카카오스토리의 프로필 가져오기 API를 사용하려면 이 발급받은 토큰이 필요하다. 이 과정이 <a href=\"#protocol-flow\">Protocol Flow</a>의 5,6번 과정에 속한다.</p>\n<h2 id=\"네이버\" style=\"position:relative;\"><a href=\"#%EB%84%A4%EC%9D%B4%EB%B2%84\" aria-label=\"네이버 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네이버</h2>\n<p>네이버도 OAuth를 이용하며, <a href=\"https://developers.naver.com/docs/login/api/api.md\">네이버 로그인 API 명세</a>에서 확인할 수 있다. 카카오와 마찬가지로 인가 코드 받기, 토큰 받기 두 과정을 거친다. 이렇게 발급받은 토큰을 사용하여 회원 프로필 조회 API, 카페 API 등을 사용할 수 있다.</p>\n<h1 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h1>\n<p>이 포스팅은 소셜 로그인 구현에 도움이 되는 내용에 초점을 맞춰 생략된 부분이 많다. 만약 OAuth 2.0에 대해 더 자세히 알고 싶다면, <a href=\"https://datatracker.ietf.org/doc/html/rfc6749\">RFC 6749</a>을 참고하는 것이 좋다.</p>","frontmatter":{"title":"OAuth에 대하여 알아보자.","date":"October 22, 2021"}}},"pageContext":{"slug":"/development/rfc6749-oauth2/","previous":{"fields":{"slug":"/toy-project/web-canvas/"},"frontmatter":{"title":"웹 에디터로 이미지를 만들어보자"}},"next":null}},
    "staticQueryHashes": ["3078735561","3128451518"]}