{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Dev Logs","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"개요 코틀린에서 자주 사용하는 관용구를 알아보자. DTO 생성 (POJOs/POCOs)  클래스는 다음 기능을 제공한다. 모든 프로퍼티의 getter와 setter (setter는  인 경우만 제공 )     모든 프로퍼티의 , , …, 제공  (Data classes 참조) 함수 매개변수의 기본값 리스트 필터 또는 짧은 버전으로: Java와 Kotlin…","fields":{"slug":"/kotlin/basic-idioms/"},"frontmatter":{"date":"October 29, 2021","title":"코틀린 관용구 (Idioms)","category":"kotlin","draft":false}}},{"node":{"excerpt":"개요 예제를 통하여 코틀린의 기본 문법을 알아보자. 패키지 정의 및 가져오기 패키지는 소스 파일의 최상단에 선언하여야 한다. 디렉토리와 패키지는 일치시키지 않아도 상관없다. Packages 참조 프로그램 시작점 코틀린 어플리케이션의 시작점은  함수이다.  함수는  매개변수를 받을 수 있다. 표준 출력  는 입력 받은 매개변수를 표준 출력한다. 는 입력 받…","fields":{"slug":"/kotlin/basic-syntax/"},"frontmatter":{"date":"October 29, 2021","title":"코틀린 기본 문법","category":"kotlin","draft":false}}},{"node":{"excerpt":"개요 Conventional Commits 스펙은 명확한 커밋 히스토리를 생성하기 위해 간단한 규칙을 제공한다. 구조 커밋 메시지는 다음과 같은 구조이어야 한다. 타입을 명시한 뒤에는 과 이 존재해야 한다. 설명은 코드 변경 사항에 대한 짧은 요약이다. 본문에는 코드 변경 사항에 대한 추가적인 정보를 제공한다. 본문은 반드시 설명 다음 빈 행으로 시작해야…","fields":{"slug":"/git/conventional-commits/"},"frontmatter":{"date":"October 28, 2021","title":"Conventional Commit (커밋 규칙)","category":"git","draft":false}}},{"node":{"excerpt":"자바에서 열거 타입을 지원하기 전에는 아래와 같이 정수 상수를 선언해 사용했었다. 정수 열거 패턴 이 같은 정수 열거 패턴은 단점이 많다. 타입 안전을 보장할 방법이 없으며 표현력도 좋지 않다.  처럼 동등 연산자로 비교하더라도  값이 나온다. 문자열로 출력하기가 어렵기 때문에 디버깅이 어렵다. 열거 그룹 안에 있는 모든 상수를 순회할 방법도 없으며, 총…","fields":{"slug":"/effective-java/item-34-use-enums-instead-of-int-constants/"},"frontmatter":{"date":"October 25, 2021","title":"int 상수 대신 열거 타입을 사용하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"소개 OAuth는 오픈 API의 인증(authentication)과 권한 부여(authorization)를 제공하기 위해 만들어진 프로토콜이다. OAuth 1.0과 OAuth 2.0이 있는데, 현재는 RFC 5849에서 설명하는 OAuth 1.0을 폐기하고, RFC 6749에 설명된 OAuth 2.0 방식을 사용한다. 이번 포스팅에서는 OAuth 2.0에…","fields":{"slug":"/development/rfc6749-oauth2/"},"frontmatter":{"date":"October 22, 2021","title":"OAuth에 대하여 알아보자.","category":"development","draft":false}}},{"node":{"excerpt":"소개 웹 상에서 간단한 이미지를 제작할 수 있는 사이트입니다. 이용해 보시려면 여기 를 클릭해주세요.  기능 소개 캔버스 조정 캔버스 색상 변경과 크기를 조정할 수 있어요. 캔버스 조정 이미지 추가 사용자의 컴퓨터에 있는 이미지를 추가할 수 있어요. 캔버스 조정 텍스트 텍스트를 추가하고 텍스트 스타일을 변경할 수 있어요. 텍스트 도형 동그라미, 세모, 네…","fields":{"slug":"/toy-project/web-canvas/"},"frontmatter":{"date":"October 21, 2021","title":"웹 에디터로 이미지를 만들어보자","category":"toy-project","draft":false}}},{"node":{"excerpt":"개요 ITEM 28에서 이야기 했듯 과 같은 매개변수화(parameterized) 타입은 불공변이다. 은 의 하위 타입이 아니며, 는 의 상위 타입이 아니라는 것이다. 하지만 때로는 불공변 방식보다 유연한 무언가가 필요할 때가 있다. 예시 코드를 살펴보며 유연한 API를 만들 수 있는 방법을 알아보자. 예시 다음과 같은  클래스가 있다고 하자. 클라이언트…","fields":{"slug":"/effective-java/item-31-use-bounded-wildcards/"},"frontmatter":{"date":"October 20, 2021","title":"ITEM 31. 한정적 와일드카드를 사용해 API 유연성을 높여라","category":"effective-java","draft":false}}},{"node":{"excerpt":"배열과 제네릭의 차이 배열과 제네릭에는 중요한 두 가지 차이가 있다. 첫 번째 차이점은 배열은 공변(covariant)인 반면 제네릭은 불공변(invariant)라는 것이며, 두 번째 차이점은 배열은 실체화(reify)되지만 리스트는 그렇지 않다는 것이다. 공변과 불공변 공변이란 가 의 하위 타입이라면 배열 는 배열 의 하위타입이 된다는 의미이다. 불공변…","fields":{"slug":"/effective-java/item-28-prefer-lists-to-arrays/"},"frontmatter":{"date":"October 20, 2021","title":"ITEM 28. 배열보다는 리스트를 사용하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"불변 클래스 불변 클래스란 그 인스턴스 내부의 값을 수정할 수 없는 클래스를 말한다. 자바 플랫폼 라이브러리에도 String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal이 불변 클래스에 속한다. 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다. 클래스를 불변으로 만들기 …","fields":{"slug":"/effective-java/item-17-minimize-mutability/"},"frontmatter":{"date":"October 18, 2021","title":"ITEM 17. 변경 가능성을 최소화하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"개요 불변 객체와 참조 투명성에 대하여 알아보고, 예제를 통하여 불변 객체가 갖는 장점을 알아보자. 참조 투명성 (Referential transparency) ‘참조 투명성’은 함수가 함수 외부의 영향을 받지 않는 것을 의미한다. 이렇게 외부의 영향을 받지 않는 코드를 가리켜 “참조에 투명 하다.” 라고 할 수 있다. 불변 객체 (Immutable ob…","fields":{"slug":"/java/immutable-object-and-referential-transparency/"},"frontmatter":{"date":"October 14, 2021","title":"불변 객체와 참조 투명성","category":"java","draft":false}}},{"node":{"excerpt":"불필요한 객체 생성 피하기 똑같은 기능의 객체를 매번 생성하기보다 객체 하나를 재사용 하는 것이 나을 때가 많다. 특히 불변 객체라면 언제든지 재사용 할 수 있다. 불필요한 객체를 생성하는 코드는 다음과 같은 것이 있다. 위 코드는 실행될 때마다 새로운 String 인스턴스를 만든다. 생성자에 넘겨진 “bikini” 자체가 생성자로 만들려는 String과…","fields":{"slug":"/effective-java/item-6-avoid-creating-unnecessary-objects/"},"frontmatter":{"date":"October 13, 2021","title":"ITEM 6. 불필요한 객체 생성을 피하라.","category":"effective-java","draft":false}}},{"node":{"excerpt":"맞춤법 검사기를 개선하며 의존 객체 주입의 장점을 알아보자. 맞춤법 검사기에는 맞춤법 검사를 위한 사전인  과 맞춤법이 맞는 지 판단하는  메서드가 존재한다고 가정한다.  다음 코드는 맞춤법 검사기를 정적 유틸리티 클래스를 통하여 구현한 모습이다. 정적 유틸리티 클래스 사용 이와 비슷하게 싱글턴으로 구현하는 방법도 있다. 싱글턴 사용 두 방식의 문제점은 …","fields":{"slug":"/effective-java/item-5-prefer-dependency-injection/"},"frontmatter":{"date":"October 13, 2021","title":"ITEM 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"아래와 같이 식품 영양 정보를 표현하는 클래스가 있다. 이런 클래스에 생성자를 사용하여 값을 입력받으려면 어떻게 될까? 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 필수 매개변수와 선택 매개변수 2개를 받는 생성자… 이런 형태로 생성자를 늘려나가야 할 것이다. 이러한 방식을 점층적 생성자 패턴(telescoping c…","fields":{"slug":"/effective-java/item-2-consider-a-builder/"},"frontmatter":{"date":"October 10, 2021","title":"ITEM 2. 생성자에 매개변수가 많다면 빌더를 고려하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"생성자 대신 정적 팩터리 메서드를 사용할때의 장점과 단점을 알아보자 장점 1. 이름을 갖을 수 있다. 반환 될 객체의 특성을 명확히 알 수 있는 이름을 지을 수 있다. 예를들어 생성자인  보다 정적 팩터리 메서드인  쪽이 ‘값이 소수인 BigInteger를 반환한다’는 의미를 더 잘 들어낼 수 있다. 또 생성자는 하나의 시그니처로 하나의 생성자만 만들 수…","fields":{"slug":"/effective-java/item-1-consider-static-factory-method/"},"frontmatter":{"date":"October 10, 2021","title":"ITEM 1. 생성자 대신 정적 팩터리 메서드를 고려하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"개요 포인트컷 표현식과 트랜잭션 속성을 이용하면 트랜잭션을 일괄적으로 적용할 수 있다. 하지만 클래스나 메소드에 따라 다른 트랜잭션 속성을 적용해야 하는 경우가 있다. 이런 세밀한 트랜잭션 속성의 제어가 필요한 경우를 위해 스프링에서는  을 제공한다. 트랜잭션 어노테이션 다음은 트랜잭션 어노테이션을 정의한 코드이다. 트랜잭션 어노테이션은 메소드, 클래스,…","fields":{"slug":"/toby-spring/transaction-annotation/"},"frontmatter":{"date":"October 08, 2021","title":"트랜잭션 어노테이션","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 포인트컷 표현식과 트랜잭션 속성을 이용하면 트랜잭션을 일괄적으로 적용할 수 있다. 하지만 클래스나 메소드에 따라 다른 트랜잭션 속성을 적용해야 하는 경우가 있다. 이런 세밀한 트랜잭션 속성의 제어가 필요한 경우를 위해 스프링에서는  을 제공한다. 트랜잭션 어노테이션 다음은 트랜잭션 어노테이션을 정의한 코드이다. 트랜잭션 어노테이션은 메소드, 클래스,…","fields":{"slug":"/git/git-empty-directory/"},"frontmatter":{"date":"October 07, 2021","title":"깃 빈 디렉토리 커밋","category":"git","draft":false}}},{"node":{"excerpt":"개요 트랜잭션은 더이상 쪼갤 수 없는 최소 단위의 작업이라는 사실에는 변함이 없지만, 트랜잭션이 모두 같은 방식으로 동작하는 것은 아니다. 스프링이 제공하는  인터페이스는 트랜잭션의 동작 방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다. 이를 이용해 트랜잭션의 동적방식을 제어할 수 있다. 기본적으로 사용하는 속성은  이며, 자세한 내용은 이번 포…","fields":{"slug":"/toby-spring/transaction-definition/"},"frontmatter":{"date":"October 01, 2021","title":"트랜잭션 속성","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 Java8 에서 추가된  클래스에 대해 알아보자. 미리 정의된 인스턴스  에는 ISO 및 RFC 표준을 따라 정의되어 있는 날짜/시간 포맷을 제공한다. 예를들어  인스턴스를 사용하여 다음과 같이 ‘2021-09-29’ 와 같은 문자열을 얻을 수 있다. 만약 ‘2021-09-29+09:00’ 와 같이 오프셋을 포함한 문자열을 구하고 싶다면  를 사용한…","fields":{"slug":"/java/date-time-formatter/"},"frontmatter":{"date":"September 29, 2021","title":"자바 날짜 포맷","category":"java","draft":false}}},{"node":{"excerpt":"개요 Isolation level은 트랜잭션에서 일관성이 없는 데이터를 허용하는 수준이다. isolation level이 낮을수록 많은 사용자가 동일한 데이터에 동시에 접근할 수 있는 성능이 향상된다. 그러나 이는 잘 못된 데이터를 읽거나 데이터의 업데이트가 손실되는 등과 같은 증상을 유발할 수 있다. 반대로 isolation level이 높을수록 문제가…","fields":{"slug":"/database/isolation-level/"},"frontmatter":{"date":"September 28, 2021","title":"격리 수준 (Isolation level)","category":"database","draft":false}}},{"node":{"excerpt":"개요 GitHub Action을 사용하여 깃허브 페이지 배포를 자동화하는 방법을 알아보자. Workflows  는 하나 이상의 작업으로 구성된 자동화 프로세스이다. 워크플로는  또는  파일을 생성하여 구성할 수 있으며, 반드시 레포지토리의  폴더에 저장되어야 한다. 구성 파일을 작성 방법은 workflow syntax for github actions에서…","fields":{"slug":"/git/github-pages-auto-deployment/"},"frontmatter":{"date":"September 28, 2021","title":"깃허브 페이지 배포 자동화","category":"git","draft":false}}},{"node":{"excerpt":"개요 이전 포스트에서 프록시 팩토리와 한계점에 관하여 알아보았다. 이번 포스트에서는 이러한 한계점을 스프링은 어떤 방식으로 해결책을 제시하였는지 알아보자. ProxyFactoryBean 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.  이 스프링에서 제공해주는 팩토리 빈이다.  을 상속받아서 구현했던 TxProxyFactor…","fields":{"slug":"/toby-spring/proxy-3-proxy-factory-bean/"},"frontmatter":{"date":"September 27, 2021","title":"프록시 3 - 프록시 팩토리 빈과 빈 후처리기","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 이번 포스트에서는 이전 포스트에서 다뤘던 프록시의 문제를 해결하기 위한 다이내믹 프록시에 대해서 알아보고, 다이내믹 프록시를 적용하여 기존 코드의 문제를 해결해보자. 리플렉션 다이내믹 프록시를 이해하려면 우선 리플렉션에 대해 알아야한다. 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있도록 만든 것이며, 이를 쉽게 사용하도록  패키지를 제공한다…","fields":{"slug":"/toby-spring/proxy-2-dynamic-proxy/"},"frontmatter":{"date":"September 27, 2021","title":"프록시 2 - 다이내믹 프록시와 팩토리 빈","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 트랜잭션 추상화 기법을 적용한 서비스를 리팩토링 해가며 프록시의 개념을 이해하고, 프록시를 활용한 디자인 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아보자. Service 트랜잭션 서비스 추상화 포스트에서 다음과 같은 유저 등급 설정 메서드를 만든 적이 있다. 코드를 자세히 살펴보면 트랜잭션의 경계를 설정하는 코드와 비지니스 로직으로 구분할 수 …","fields":{"slug":"/toby-spring/proxy-1-proxy-and-pattern/"},"frontmatter":{"date":"September 27, 2021","title":"프록시 1 - 프록시와 프록시를 사용한 패턴","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 트랜잭션 기능을 사용한 서비스를 리팩토링 해가며 스프링에서 트랜젝션 서비스를 어떤 방식으로 제공해 주는지 알아보자. Service 다음과 같이 사용자의 등급을 올리는 서비스 메서드가 있다고 하자. 이 서비스는 작업을 수행하는 도중 오류가 발생하여도, 오류가 발생하기 전까지 변경된 사용자의 레벨은 변경된 상태로 유지된다. 오류가 발생할 경우 변경된 내…","fields":{"slug":"/toby-spring/abstract-transaction-model/"},"frontmatter":{"date":"September 27, 2021","title":"트랜잭션 서비스 추상화","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 JDBC를 사용한 코드의 문제점을 확인하고, 문제점을 하나씩 수정해가면서 템플릿/콜백 패턴을 이해해보자. DAO JDBC를 사용해본 경험이 있다면 다음과 같은 코드를 본 기억이 있을 것이다. 자바 7 이상 버전이라면  를 사용해야겠지만, 앞으로 설명할 템플릿 콜백 패턴을 더 잘 설명하기 위해 이와 같은 코드를 작성하였다. 이 코드는 예외 처리를 하여…","fields":{"slug":"/toby-spring/template-callback/"},"frontmatter":{"date":"September 27, 2021","title":"템플릿/콜백 패턴의 이해","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 전 단계의 아웃풋이 다음 단계의 인풋으로 구성되는 파이프라인이 필요했다. 또 파이프라인 전, 후, 중간으로 단계를 추가, 수정, 삭제하기 용이해야 했다. 요구 사항을 만족하는 방법을 찾던 중 괜찮은 자료가 있어 포스팅 하게 되었다. Step Interface 파이프라인을 구성하는 각각의 단계에 해당하는 인터페이스 Pipeline Class 각각의 단…","fields":{"slug":"/design-pattern/pipeline-pattern/"},"frontmatter":{"date":"July 09, 2019","title":"Pipeline Pattern (파이프라인 패턴)","category":"design-pattern","draft":false}}},{"node":{"excerpt":"개요 역할 기반 접근 제어(RBAC: Role Based Access Control)는 사용자의 역할에 따라 권한을 구분하고, 권한이 없는 사용자에게는 시스템 접근을 제한하는 방법이다. 사전에 역할을 미리 정의해두고 사용자에게 역할을 부여함으로써 권한을 제어한다. 이번 포스트에서는 역할 기반 접근 제어를 위한 테이블을 설계해볼 것이다. 간단한 솔루션 St…","fields":{"slug":"/database/role-based-access-control-table-structure/"},"frontmatter":{"date":"June 15, 2019","title":"역할 기반 접근 제어를 위한 테이블 설계","category":"database","draft":false}}},{"node":{"excerpt":"개요 유니온 파인드는 Disjoint Set (서로소 집합) 또는 Merge Find Set (병렬 찾기 집합) 으로 불리며, 말 그대로 서로소인 집합들을 표현하는 자료구조이다. 즉, 어떤 집합 사이에도 교집합의 원소가\n하나도 없고, 모든 집합의 합집합은 전체 집합과 같다는 말이다. 기본적으로 union, find 단 2개의 연산만을 지원한다. 예시 {1…","fields":{"slug":"/data-structure/union-find/"},"frontmatter":{"date":"June 05, 2019","title":"Union-Find (유니온 파인드)","category":"data-structure","draft":false}}},{"node":{"excerpt":"개요 Inverted index(역방향 인덱스)는 대용량 텍스트 검색을 위해서 고안된 방법이다. 요즘 많이 사용하는 해시태그 기능을 구현하고 싶다면 역방향 인덱스 방법을 사용할 수 있으며, 대부분의 검색 엔진이 이 방식을\n사용한다. 기존의 검색 방식 WHERE =  검색어와 정확히 일치하는 문서만 검색된다. 인덱스가 걸려있을 경우 속도는 빠를 수 있지만,…","fields":{"slug":"/data-structure/inverted-index/"},"frontmatter":{"date":"April 24, 2019","title":"Inverted index (역색인)","category":"data-structure","draft":false}}}]}},"pageContext":{}},
    "staticQueryHashes": ["3078735561","3128451518"]}