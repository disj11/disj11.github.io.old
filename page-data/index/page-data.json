{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Dev Logs","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"아래와 같이 식품 영양 정보를 표현하는 클래스가 있다. 이런 클래스에 생성자를 사용하여 값을 입력받으려면 어떻게 될까? 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 필수 매개변수와 선택 매개변수 2개를 받는 생성자… 이런 형태로 생성자를 늘려나가야 할 것이다. 이러한 방식을 점층적 생성자 패턴(telescoping c…","fields":{"slug":"/effective-java/consider-a-builder/"},"frontmatter":{"date":"October 10, 2021","title":"ITEM2. 생성자에 매개변수가 많다면 빌더를 고려하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"생성자 대신 정적 팩터리 메서드를 사용할때의 장점과 단점을 알아보자 장점 1. 이름을 갖을 수 있다. 반환 될 객체의 특성을 명확히 알 수 있는 이름을 지을 수 있다. 예를들어 생성자인  보다 정적 팩터리 메서드인  쪽이 ‘값이 소수인 BigInteger를 반환한다’는 의미를 더 잘 들어낼 수 있다. 또 생성자는 하나의 시그니처로 하나의 생성자만 만들 수…","fields":{"slug":"/effective-java/consider-static-factory-method/"},"frontmatter":{"date":"October 10, 2021","title":"ITEM1. 생성자 대신 정적 팩터리 메서드를 고려하라","category":"effective-java","draft":false}}},{"node":{"excerpt":"개요 포인트컷 표현식과 트랜잭션 속성을 이용하면 트랜잭션을 일괄적으로 적용할 수 있다. 하지만 클래스나 메소드에 따라 다른 트랜잭션 속성을 적용해야 하는 경우가 있다. 이런 세밀한 트랜잭션 속성의 제어가 필요한 경우를 위해 스프링에서는  을 제공한다. 트랜잭션 어노테이션 다음은 트랜잭션 어노테이션을 정의한 코드이다. 트랜잭션 어노테이션은 메소드, 클래스,…","fields":{"slug":"/toby-spring/transaction-annotation/"},"frontmatter":{"date":"October 08, 2021","title":"트랜잭션 어노테이션","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 포인트컷 표현식과 트랜잭션 속성을 이용하면 트랜잭션을 일괄적으로 적용할 수 있다. 하지만 클래스나 메소드에 따라 다른 트랜잭션 속성을 적용해야 하는 경우가 있다. 이런 세밀한 트랜잭션 속성의 제어가 필요한 경우를 위해 스프링에서는  을 제공한다. 트랜잭션 어노테이션 다음은 트랜잭션 어노테이션을 정의한 코드이다. 트랜잭션 어노테이션은 메소드, 클래스,…","fields":{"slug":"/git/git-empty-directory/"},"frontmatter":{"date":"October 07, 2021","title":"깃 빈 디렉토리 커밋","category":"git","draft":false}}},{"node":{"excerpt":"개요 트랜잭션은 더이상 쪼갤 수 없는 최소 단위의 작업이라는 사실에는 변함이 없지만, 트랜잭션이 모두 같은 방식으로 동작하는 것은 아니다. 스프링이 제공하는  인터페이스는 트랜잭션의 동작 방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다. 이를 이용해 트랜잭션의 동적방식을 제어할 수 있다. 기본적으로 사용하는 속성은  이며, 자세한 내용은 이번 포…","fields":{"slug":"/toby-spring/transaction-definition/"},"frontmatter":{"date":"October 01, 2021","title":"트랜잭션 속성","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 Java8 에서 추가된  클래스에 대해 알아보자. 미리 정의된 인스턴스  에는 ISO 및 RFC 표준을 따라 정의되어 있는 날짜/시간 포맷을 제공한다. 예를들어  인스턴스를 사용하여 다음과 같이 ‘2021-09-29’ 와 같은 문자열을 얻을 수 있다. 만약 ‘2021-09-29+09:00’ 와 같이 오프셋을 포함한 문자열을 구하고 싶다면  를 사용한…","fields":{"slug":"/java/date-time-formatter/"},"frontmatter":{"date":"September 29, 2021","title":"자바 날짜 포맷","category":"java","draft":false}}},{"node":{"excerpt":"개요 Isolation level은 트랜잭션에서 일관성이 없는 데이터를 허용하는 수준이다. isolation level이 낮을수록 많은 사용자가 동일한 데이터에 동시에 접근할 수 있는 성능이 향상된다. 그러나 이는 잘 못된 데이터를 읽거나 데이터의 업데이트가 손실되는 등과 같은 증상을 유발할 수 있다. 반대로 isolation level이 높을수록 문제가…","fields":{"slug":"/database/isolation-level/"},"frontmatter":{"date":"September 28, 2021","title":"격리 수준 (Isolation level)","category":"database","draft":false}}},{"node":{"excerpt":"개요 GitHub Action을 사용하여 깃허브 페이지 배포를 자동화하는 방법을 알아보자. Workflows  는 하나 이상의 작업으로 구성된 자동화 프로세스이다. 워크플로는  또는  파일을 생성하여 구성할 수 있으며, 반드시 레포지토리의  폴더에 저장되어야 한다. 구성 파일을 작성 방법은 workflow syntax for github actions에서…","fields":{"slug":"/git/github-pages-auto-deployment/"},"frontmatter":{"date":"September 28, 2021","title":"깃허브 페이지 배포 자동화","category":"git","draft":false}}},{"node":{"excerpt":"개요 이전 포스트에서 프록시 팩토리와 한계점에 관하여 알아보았다. 이번 포스트에서는 이러한 한계점을 스프링은 어떤 방식으로 해결책을 제시하였는지 알아보자. ProxyFactoryBean 스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공해준다.  이 스프링에서 제공해주는 팩토리 빈이다.  을 상속받아서 구현했던 TxProxyFactor…","fields":{"slug":"/toby-spring/proxy-3-proxy-factory-bean/"},"frontmatter":{"date":"September 27, 2021","title":"프록시 3 - 프록시 팩토리 빈과 빈 후처리기","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 이번 포스트에서는 이전 포스트에서 다뤘던 프록시의 문제를 해결하기 위한 다이내믹 프록시에 대해서 알아보고, 다이내믹 프록시를 적용하여 기존 코드의 문제를 해결해보자. 리플렉션 다이내믹 프록시를 이해하려면 우선 리플렉션에 대해 알아야한다. 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있도록 만든 것이며, 이를 쉽게 사용하도록  패키지를 제공한다…","fields":{"slug":"/toby-spring/proxy-2-dynamic-proxy/"},"frontmatter":{"date":"September 27, 2021","title":"프록시 2 - 다이내믹 프록시와 팩토리 빈","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 트랜잭션 추상화 기법을 적용한 서비스를 리팩토링 해가며 프록시의 개념을 이해하고, 프록시를 활용한 디자인 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아보자. Service 트랜잭션 서비스 추상화 포스트에서 다음과 같은 유저 등급 설정 메서드를 만든 적이 있다. 코드를 자세히 살펴보면 트랜잭션의 경계를 설정하는 코드와 비지니스 로직으로 구분할 수 …","fields":{"slug":"/toby-spring/proxy-1-proxy-and-pattern/"},"frontmatter":{"date":"September 27, 2021","title":"프록시 1 - 프록시와 프록시를 사용한 패턴","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 트랜잭션 기능을 사용한 서비스를 리팩토링 해가며 스프링에서 트랜젝션 서비스를 어떤 방식으로 제공해 주는지 알아보자. Service 다음과 같이 사용자의 등급을 올리는 서비스 메서드가 있다고 하자. 이 서비스는 작업을 수행하는 도중 오류가 발생하여도, 오류가 발생하기 전까지 변경된 사용자의 레벨은 변경된 상태로 유지된다. 오류가 발생할 경우 변경된 내…","fields":{"slug":"/toby-spring/abstract-transaction-model/"},"frontmatter":{"date":"September 27, 2021","title":"트랜잭션 서비스 추상화","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 JDBC를 사용한 코드의 문제점을 확인하고, 문제점을 하나씩 수정해가면서 템플릿/콜백 패턴을 이해해보자. DAO JDBC를 사용해본 경험이 있다면 다음과 같은 코드를 본 기억이 있을 것이다. 자바 7 이상 버전이라면  를 사용해야겠지만, 앞으로 설명할 템플릿 콜백 패턴을 더 잘 설명하기 위해 이와 같은 코드를 작성하였다. 이 코드는 예외 처리를 하여…","fields":{"slug":"/toby-spring/template-callback/"},"frontmatter":{"date":"September 27, 2021","title":"템플릿/콜백 패턴의 이해","category":"toby-spring","draft":false}}},{"node":{"excerpt":"개요 역할 기반 접근 제어(RBAC: Role Based Access Control)는 사용자의 역할에 따라 권한을 구분하고, 권한이 없는 사용자에게는 시스템 접근을 제한하는 방법이다. 사전에 역할을 미리 정의해두고 사용자에게 역할을 부여함으로써 권한을 제어한다. 이번 포스트에서는 역할 기반 접근 제어를 위한 테이블을 설계해볼 것이다. 간단한 솔루션 St…","fields":{"slug":"/database/role-based-access-control-table-structure/"},"frontmatter":{"date":"June 15, 2019","title":"역할 기반 접근 제어를 위한 테이블 설계","category":"database","draft":false}}}]}},"pageContext":{}},
    "staticQueryHashes": ["3078735561","3128451518"]}