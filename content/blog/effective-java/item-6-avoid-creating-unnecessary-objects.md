---
title: ITEM 6. 불필요한 객체 생성을 피하라.
date: 2021-10-13 20:10:85
category: effective-java
draft: false
---

## 불필요한 객체 생성 피하기

똑같은 기능의 객체를 매번 생성하기보다 객체 하나를 재사용 하는 것이 나을 때가 많다. 특히 불변 객체라면 언제든지 재사용 할 수 있다. 불필요한 객체를 생성하는 코드는 다음과 같은 것이 있다.

```java
String s = new String("bikini");
```

위 코드는 실행될 때마다 새로운 String 인스턴스를 만든다. 생성자에 넘겨진 "bikini" 자체가 생성자로 만들려는 String과 기능적으로 완전히 일치하기 때문에 이는 완전히 불필요한 행위이다. 대신 아래와 같이 사용할 수 있다.

```java
String s = "bikini";
```

이렇게 큰따옴표로 둘러싼 문자의 연속체를 문자열 리터럴이라고 한다. 같은 JVM 안에서 같은 문자열 리터럴을 사용하게 되면 항상 객은 객체를 재사용함이 보장되므로 이 방식을 사용하자. 같은 맥락으로 `Boolean(String)` 생성자 대신 `Boolean.valueOf(String)` 팩터리 메서드를 사용하는 것이 좋다.

불필요한 객체를 생성하는 다른 예로는 오토박싱(auto boxing)이 있다. 다음 예시는 모든 양의 정수의 합을 구하는 코드이다.

```java
private static long sum() {
	Long sum = 0L;
	for (long i = 0; i <= Integer.MAX_VALUE; i++) {
		sum += i;
	}
	return sum;
}
```

이 코드가 정확한 답을 내기는 하지만 제대로 구현했을 때보다 훨씬 느리다. sum 변수를 `long`이 아닌 `Long`으로 만드는 실수를 했기 때문이다. 이런 사소한 실수로 불필요한 Long 인스턴스가 약 2<sup>31</sup>개나 만들어진 것이다. 단순히 sum의 타입을 long으로만 바꿔줘도 6.3초에서 0.59초로 빨라지는 것을 볼 수 있었다. 예제의 결과로 보듯이 **박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱 사용에 주의하자.**

## 생성 비용이 비싼 객체는 캐싱하여 사용하기

생성 비용이 '비싼 객체'를 반복해서 사용해야 한다면 캐싱하여 재사용하는 것이 좋다. 안타깝게도 자신이 만드는 객체가 비싼 객체인지 매번 명확히 알 방법은 없지만 한 가지 예가 있다. 아래와 같이 문자열이 유효한 로마 숫자인지 확인하는 메서드를 작성한다고 해보자.

```java
static boolean isRomanNumeral(String s) {
	return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$";
}
```

이 코드의 문제점은 `String.matches` 메서드를 사용한다는 데 있다. **String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이나, 성능이 중요한 상황에서 반복적으로 사용하는 데에는 적합하지 않다.** 이 메서드 내부에서 사용하는 Pattern 인스턴스는, 한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 되며, 입력받은 정규표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에 인스턴스 생성 비용이 높다. 때문에 아래와 같이 작성하는 것이 좋다.

```java
public class RomanNumerals {
	private static final Pattern ROMAN = Pattern.compile("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

	static boolean isRomanNumeral(String s) {
		return ROMAN.matcher(s).matches();
	}
}
```

이렇게 개선하면 `isRomanNumeral` 이 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다. 길이가 8인 문자열로 비교하였을때 개선 전 1.1㎲에서 개선 후 0.17㎲로 6.5배 정도 빨라진 것을 확인할 수 있었다.

## 정리

이번 주제는 객체 생성은 비싸니 피해야 한다는 것이 아니다. 요즘의 JVM은 작은 객체를 생성하고 소비하는 일이 크게 부담되지 않기 때문에 프로그램의 명확성, 간결성, 기능을 위해 객체를 생성하는 일은 일반적으로 좋은 일이다. 거꾸로 아주 무거운 객체가 아닌 상황에서 객체 풀(pool)을 만들지는 말자. 오히려 메모리 사용량을 늘리고, 성능을 떨어뜨릴 수 있다.

방어적 복사가 필요한 상황에서 객체를 재사용하게 되었을 때는 버그와 보안 이슈 등으로 이어지는 큰 피해를 주지만, 불필요한 객체 생성은 그저 성능에만 영향을 준다는 사실을 기억하자.